---
layout: post
title:  "G1 堆初始化"
date:   2024-08-10 11:00:00 +0200
tags: [GC, G1]
---

[前文](https://yoa1226.github.io/2024/08/05/g1-gc-important-component.html) 介绍了 G1 非常重要多的重要概念，并介绍了相关的源码，这些概念在后续文章中会重复的提到。了解完成上述概念以后，本文将开始介绍堆初始化相关的内容。

## 启动 JVM

JVM进程本质上也是一个操作系统进程，通常我们使用下面的命令启动 Java 程序。

```shell
java -jar -Xmx1024m -Xms1024m yyy.jar
```

这里 java 是编译好的可执行文件，可在 `shell` 中执行。简单来说，操作系统会对文件的格式进行解析，创建出进程所需要的地址空间，然后跳转到 `main` 函数执行用户代码。

### main 函数

JVM 是 c++ 开发的，入口函数应该是 `main` 函数：

```cpp
//jdk/src/jdk.jpackage/linux/native/applauncher/LinuxLauncher.c
int main(int argc, char *argv[]) {
    //omit
    exitCode = launchJvm(jvmLauncherData);
}
```

下面简单地罗列调用栈，主要是函数指针的获取代码。

```cpp
//-> launchJvm
JLI_Launch = dlsym(jliLibHandle, "JLI_Launch");

//->jvmLauncherStartJvm->JNIEXPORT int JNICALL JLI_Launch

//-> LoadJavaVM
ifn->CreateJavaVM = (CreateJavaVM_t) dlsym(libjvm, "JNI_CreateJavaVM");

//->JVMInit -> ContinueInNewThread -> CallJavaMainInNewThread
```

在函数 `CallJavaMainInNewThread`  中尝试创建新的线程执行虚拟机启动，然后执行 `JavaMain`。

```cpp
if (pthread_create(&tid, &attr, ThreadJavaMain, args) == 0) {
        pthread_join(tid, &tmp);
    } else {
        rslt = JavaMain(args);
    }
```

在函数 `JavaMain` 中可以看到很多熟悉的内容，比如 Java `main` 方法的调用，而且可以看到 `main` 没有参数也是可以运行的。

```cpp
if (!InitializeJVM(&vm, &env, &ifn)) {}

mainClass = LoadMainClass(env, mode, what);
mainArgs = CreateApplicationArgs(env, argv, argc)

PostJVMInit(env, appClass, vm);

ret = invokeStaticMainWithoutArgs(env, mainClass);

ret = invokeStaticMainWithArgs(env, mainClass, mainArgs);
```

`LoadMainClass`函数内部调用 `sun.launcher.LauncherHelper#checkAndLoadMain` 获取主类对应的`Class`实例。

### JVM 创建

接着看创建 JVM 代码，能看到很多熟悉的东西，agent、main thread、synchronizer、Metaspace。

```cpp
//InitializeJVM->JNI_CreateJavaVM ->JNI_CreateJavaVM_inner
//-> JNI_CreateJavaVM_inner->Threads::create_vm
jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
  
  JvmtiAgentList::load_agents()

  // Attach the main thread to this os thread
  JavaThread* main_thread = new JavaThread();
  
  // Initialize Java-Level synchronization subsystem
  ObjectMonitor::Initialize();
  ObjectSynchronizer::initialize();

    // Initialize global modules
  jint status = init_globals();

  Metaspace::post_initialize();
  //omit
}
```
### Java 堆创建

接着看找到 JVM 堆创建的代码

```cpp
//init_globals -> universe_init
GCConfig::arguments()->initialize_heap_sizes();

//->Universe::initialize_heap()
jint Universe::initialize_heap() {
  _collectedHeap = GCConfig::arguments()->create_heap();
  return _collectedHeap->initialize();
}
// _collectedHeap 是 G1CollectedHeap
G1CollectedHeap::initialize();
```

#### GC 类型选择

未指定 GC 的情况下，JVM 通过 `select_gc_ergonomically` 函数在服务端模式默认选择 G1。

```cpp
// GCConfig::initialize()->select_gc()
GCArguments* GCConfig::select_gc() {
  if (is_no_gc_selected()) { select_gc_ergonomically(); }
  // Exactly one GC selected
  FOR_EACH_INCLUDED_GC(gc) {
    //返回 G1Arguments 
    if (gc->_flag) { return &gc->_arguments; }
  }
}

#ifndef INCLUDE_G1GC
#define INCLUDE_G1GC 1

void GCConfig::select_gc_ergonomically() {
  if (os::is_server_class_machine()) {
    #if INCLUDE_G1GC
    FLAG_SET_ERGO_IF_DEFAULT(UseG1GC, true);
    //omit
  } else { /*omit*/ }
}
```
## G1 堆初始化

## G1 堆组件

## 总结